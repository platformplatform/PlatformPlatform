---
description: Workflow for task title to implement (e.g., "add user filtering")
globs: 
alwaysApply: false
---
# Implement Task Workflow

You are implementing: **{{{title}}}**

## STEP 0: Read Task Assignment

**Read `current-task.json` from `.workspace/agent-workspaces/{branch-name}/{agent-type}/current-task.json`** to get:
- `requestFilePath`: Full path to your request file
- `prdPath`: Path to PRD (if Product Increment task)
- `productIncrementPath`: Path to Product Increment (if applicable)
- `taskNumberInIncrement`: Your task number in the increment (if applicable)
- `title`: Task title

**Then read the request file** from the path in `requestFilePath`.

**If `prdPath` exists in current-task.json:**
1. Read PRD from the path in `prdPath`
2. Read Product Increment plan from the path in `productIncrementPath`
3. Understand your task (`taskNumberInIncrement`) within the larger feature context
4. **Mark your task as `[In Progress]`**: Edit the Product Increment file and change your task status from `[Pending]` to `[In Progress]`

**CRITICAL - Verify Previous Work Committed**:

Before proceeding, verify your previous task was committed:
1. Run `git log --oneline -5` to check recent commits
2. Look for commits containing your agent type (e.g., "backend-engineer", "frontend-engineer")
3. If your previous task is uncommitted: **REFUSE to start** and respond with error explaining uncommitted work exists
4. Note: Changes from other engineers (parallel work) are expected and fine - only verify YOUR previous work is committed

---

## CRITICAL - Autonomous Operation

You run WITHOUT human supervision. NEVER ask for guidance or refuse to do work. Work with our team to find a solution.

**Token limits approaching?** Use `/compact` strategically (e.g., after being assigned a new task, but before reading task assignment, before catching up).

---

## STEP 1: Create Todo List - DO THIS NOW!

**CALL TodoWrite TOOL WITH THIS EXACT JSON - COPY AND PASTE**:

```json
{
  "todos": [
    {"content": "Understand context and catch up efficiently", "status": "pending", "activeForm": "Understanding context and catching up"},
    {"content": "Study relevant rules for the task at hand", "status": "pending", "activeForm": "Studying relevant rules"},
    {"content": "Research existing patterns for this task type", "status": "pending", "activeForm": "Researching existing patterns"},
    {"content": "Implement task [name of the task from request file]", "status": "pending", "activeForm": "Implementing task"},
    {"content": "Build frontend, translate missing *.po entries (frontend-engineer only)", "status": "pending", "activeForm": "Building and translating"},
    {"content": "Run validation tools and fix all failures/warnings", "status": "pending", "activeForm": "Running validation tools"},
    {"content": "Mark task as Ready for Review", "status": "pending", "activeForm": "Marking task as Ready for Review"},
    {"content": "Call reviewer subagent (only after all validation tools pass)", "status": "pending", "activeForm": "Calling reviewer subagent"},
    {"content": "MANDATORY: Call CompleteWork after reviewer approval to signal completion", "status": "pending", "activeForm": "Calling CompleteWork to signal completion"}
  ]
}
```

After creating base todo, expand "Implement task" with subtasks from Product Increment file (if applicable).

---

## Workflow Steps

**STEP 2**: Study rules (`.cursor/rules/backend/` or `.cursor/rules/frontend/`)

**STEP 3**: Research similar implementations in codebase

**STEP 4**: Implement each subtask, use **build** and **test** MCP tools continously

**STEP 5**: Frontend only - build and translate missing *.po entries

Run build to generate updated `*.po` files, then translate all empty `msgstr ""` entries for all supported languages. Use consistent domain terminology.

**STEP 6**: Run validation tools and fix all failures/warnings

For **backend tasks**, first run **build**, then run **format**, **test**, and **inspect** in parallel using the Task tool:
- Spawn three `backend-tool-runner` subagents simultaneously
- One runs `format`, one runs `test`, one runs `inspect`
- Wait for all three to complete
- Fix any failures or warnings (all must pass)

**Parallel execution example**:
```
In a single message, use Task tool three times:
1. Task tool → backend-tool-runner: "Run backend tool: format"
2. Task tool → backend-tool-runner: "Run backend tool: test"
3. Task tool → backend-tool-runner: "Run backend tool: inspect"
```

For **frontend tasks**, first run **build**, then run **format** and **inspect** MCP tools directly in parallel.

**STEP 7**: Edit Product Increment file: `[In Progress]` → `[Ready for Review]`

**STEP 8**: Delegate to reviewer subagent to review and commit your code

**CRITICAL - Before calling reviewer**:

1. Run `git status --porcelain` to see ALL changed files
2. Identify YOUR files (files you created/modified for THIS task):
   - Backend: Include *.Api.json files (even though in WebApp folder - generated from your API changes)
   - Frontend: Exclude *.Api.json files (these belong to backend, not you)
   - Don't forget .po translation files
   - Exclude files from parallel engineers (different agent types)
   - If you changed files outside your scope: `git restore <file>` to revert
3. List YOUR files in "Files Changed" section (one per line with status)

**Delegation format**:
```
[One short sentence: what you implemented or fixed]

## Files Changed
- path/to/file1.tsx
- path/to/file2.cs
- path/to/translations.po

Request: [path from current-task.json: requestFilePath]
Response: [response file path]
```

**Review loop**:
- If reviewer returns NOT APPROVED → Fix issues → Call reviewer subagent again
- If reviewer returns APPROVED → Check YOUR files (not parallel engineers' files) are committed → Proceed to completion
- **NEVER call CompleteWork unless reviewer approved and committed your code**
- **NEVER commit code yourself** - only the reviewer commits
- ⚠️ **If rejected 3+ times with same feedback despite validation tools passing:** Report problem with severity: error, then STOP COMPLETELY. No workarounds, no proceeding, no commits - just STOP and wait for human intervention.

**STEP 9**: Re-read Product Increment, update plan if needed

**STEP 10**: Signal completion and exit

⚠️ **CRITICAL - SESSION TERMINATING CALL**:

After completing all work AND receiving reviewer approval, you MUST call the MCP **CompleteWork** tool with `mode: "task"` to signal completion. This tool call will IMMEDIATELY TERMINATE your session - there is no going back after this call.

ALWAYS call CompleteWork after reviewer approval, even if this is the last task in a Product Increment.

**Before calling CompleteWork**:
1. Ensure all work is complete and all todos are marked as completed
2. Write a comprehensive response (what you accomplished, notes for Tech Lead)
3. Create an objective technical summary in sentence case (like a commit message)

**Call MCP CompleteWork tool**:
- `mode`: "task"
- `agentType`: Your agent type (backend-engineer, frontend-engineer, or test-automation-engineer)
- `taskSummary`: Objective technical description of what was implemented (imperative mood, sentence case). Examples: "Add team member endpoints with authorization", "Implement user avatar upload", "Fix null reference in payment processor". NEVER use subjective evaluations like "Excellent implementation" or "Clean code".
- `responseContent`: Your full response in markdown

⚠️ Your session terminates IMMEDIATELY after calling CompleteWork

---

## REMINDER: Use Exact TodoWrite JSON

**✅ DO: Copy the JSON from STEP 0**

**❌ DON'T: Create custom todo format**
